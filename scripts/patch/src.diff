diff --git a/BUILD.gn b/BUILD.gn
index bda33c185f..dc2354535d 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -4077,11 +4077,18 @@ v8_component("v8_libbase") {
 
     defines += [ "_CRT_RAND_S" ]  # for rand_s()
 
-    libs = [
-      "dbghelp.lib",
-      "winmm.lib",
-      "ws2_32.lib",
-    ]
+    if (target_os == "winuwp") {
+      libs = [
+        "winmm.lib",
+        "ws2_32.lib",
+      ]
+    } else {
+      libs = [
+        "dbghelp.lib",
+        "winmm.lib",
+        "ws2_32.lib",
+      ]
+    }
 
     data_deps += [ "//build/win:runtime_libs" ]
   }
@@ -5323,3 +5330,9 @@ if (!build_with_chromium && v8_use_perfetto) {
     ]
   }
 }  # if (!build_with_chromium && v8_use_perfetto)
+
+group("jsi") {
+  deps = [
+    "jsi:v8jsi",
+  ]
+}
\ No newline at end of file
diff --git a/DEPS b/DEPS
index 7726a6973e..9516602b5b 100644
--- a/DEPS
+++ b/DEPS
@@ -206,7 +206,7 @@ deps = {
   'test/mozilla/data':
     Var('chromium_url') + '/v8/deps/third_party/mozilla-tests.git' + '@' + 'f6c578a10ea707b1a8ab0b88943fe5115ce2b9be',
   'test/test262/data':
-    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + 'e73054f75e08e329e73e0f77bf92503ad5b83d0f',
+    Var('chromium_url') + '/external/github.com/tc39/test262.git' + '@' + '323905b70e644d90faa957235f8ac59eac4ba8ba',
   'test/test262/harness':
     Var('chromium_url') + '/external/github.com/test262-utils/test262-harness-py.git' + '@' + '4555345a943d0c99a9461182705543fb171dda4b',
   'third_party/qemu-linux-x64': {
@@ -562,4 +562,15 @@ hooks = [
       'tools/generate-header-include-checks.py',
     ],
   },
+  {
+    'name': 'rc_win',
+    'pattern': '.',
+    'condition': 'checkout_win and host_os == "win"',
+    'action': [ 'download_from_google_storage',
+                '--no_resume',
+                '--no_auth',
+                '--bucket', 'chromium-browser-clang/rc',
+                '-s', 'build/toolchain/win/rc/win/rc.exe.sha1',
+    ],
+  }
 ]
diff --git a/gni/snapshot_toolchain.gni b/gni/snapshot_toolchain.gni
index b5fb1823b3..b5ddc1aba2 100644
--- a/gni/snapshot_toolchain.gni
+++ b/gni/snapshot_toolchain.gni
@@ -66,6 +66,9 @@ if (v8_snapshot_toolchain == "") {
     # therefore snapshots will need to be built using native mksnapshot
     # in combination with qemu
     v8_snapshot_toolchain = current_toolchain
+  } else if (target_os == "winuwp") {
+    # cross compile UWP Windows with host toolchain (for x64 and x86)
+    v8_snapshot_toolchain = host_toolchain
   } else if (host_cpu == "x64") {
     # This is a cross-compile from an x64 host to either a non-Intel target
     # cpu or a different target OS. Clang will always be used by default on the
diff --git a/include/v8.h b/include/v8.h
index a839165324..75b5f4b664 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -9124,6 +9124,11 @@ class V8_EXPORT Isolate {
    */
   MicrotasksPolicy GetMicrotasksPolicy() const;
 
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable: 4996)
+#endif
+
   /**
    * Adds a callback to notify the host application after
    * microtasks were run on the default MicrotaskQueue. The callback is
@@ -9150,6 +9155,10 @@ class V8_EXPORT Isolate {
   void RemoveMicrotasksCompletedCallback(
       MicrotasksCompletedCallbackWithData callback, void* data = nullptr);
 
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
   /**
    * Sets a callback for counting the number of times a feature of V8 is used.
    */
diff --git a/src/base/debug/stack_trace_win.cc b/src/base/debug/stack_trace_win.cc
index f981bec610..c054ba8dc9 100644
--- a/src/base/debug/stack_trace_win.cc
+++ b/src/base/debug/stack_trace_win.cc
@@ -29,6 +29,35 @@ namespace v8 {
 namespace base {
 namespace debug {
 
+#ifdef WINUWP
+
+bool EnableInProcessStackDumping() {
+  return false;
+}
+
+void DisableSignalStackDump() {
+}
+
+StackTrace::StackTrace() {
+}
+
+StackTrace::StackTrace(EXCEPTION_POINTERS* exception_pointers) {
+  InitTrace(exception_pointers->ContextRecord);
+}
+
+StackTrace::StackTrace(const CONTEXT* context) { InitTrace(context); }
+
+void StackTrace::InitTrace(const CONTEXT*) {
+}
+
+void StackTrace::Print() const { OutputToStream(&std::cerr); }
+
+void StackTrace::OutputToStream(std::ostream* os) const {
+    (*os) << "==== C stack trace not implemented for WINUWP ===============================\n";
+}
+
+#else // WINUWP
+
 namespace {
 
 // Previous unhandled filter. Will be called if not nullptr when we intercept an
@@ -244,6 +273,8 @@ void StackTrace::OutputToStream(std::ostream* os) const {
   }
 }
 
+#endif // WINUWP
+
 }  // namespace debug
 }  // namespace base
 }  // namespace v8
diff --git a/src/base/platform/platform-win32.cc b/src/base/platform/platform-win32.cc
index 5db3e34310..bc3522a1de 100644
--- a/src/base/platform/platform-win32.cc
+++ b/src/base/platform/platform-win32.cc
@@ -1065,7 +1065,7 @@ Win32MemoryMappedFile::~Win32MemoryMappedFile() {
 #endif
 
 // DbgHelp isn't supported on MinGW yet
-#ifndef __MINGW32__
+#if !defined(__MINGW32__) && !defined(WINUWP)
 // DbgHelp.h functions.
 using DLL_FUNC_TYPE(SymInitialize) = BOOL(__stdcall*)(IN HANDLE hProcess,
                                                       IN PSTR UserSearchPath,
diff --git a/src/compiler/machine-operator.h b/src/compiler/machine-operator.h
index d5c03e63ca..d90c2bfe0d 100644
--- a/src/compiler/machine-operator.h
+++ b/src/compiler/machine-operator.h
@@ -198,6 +198,9 @@ ShiftKind ShiftKindOf(Operator const*) V8_WARN_UNUSED_RESULT;
 // like x64 and ia32 where a range overflow does not result in INT_MAX.
 enum class TruncateKind { kArchitectureDefault, kSetOverflowToMin };
 
+size_t hash_value(TruncateKind);
+V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream&, TruncateKind);
+
 // Interface for building machine-level operators. These operators are
 // machine-level but machine-independent and thus define a language suitable
 // for generating code to run on architectures such as ia32, x64, arm, etc.
diff --git a/src/diagnostics/unwinding-info-win64.cc b/src/diagnostics/unwinding-info-win64.cc
index f3b9a753af..ed9c79a5b3 100644
--- a/src/diagnostics/unwinding-info-win64.cc
+++ b/src/diagnostics/unwinding-info-win64.cc
@@ -527,7 +527,7 @@ void RegisterNonABICompliantCodeRange(void* start, size_t size_in_bytes) {
   // by the embedder (like Crashpad).
 
   if (RegisterUnwindInfoForExceptionHandlingOnly()) {
-#if defined(V8_OS_WIN_X64)
+#if defined(V8_OS_WIN_X64) && !defined(WINUWP)
     // Windows ARM64 starts since 1709 Windows build, no need to have exception
     // handling only unwind info for compatibility.
     if (unhandled_exception_callback_g) {
@@ -566,7 +566,7 @@ void UnregisterNonABICompliantCodeRange(void* start) {
   DCHECK(CanRegisterUnwindInfoForNonABICompliantCodeRange());
 
   if (RegisterUnwindInfoForExceptionHandlingOnly()) {
-#if defined(V8_OS_WIN_X64)
+#if defined(V8_OS_WIN_X64) && !defined(WINUWP)
     // Windows ARM64 starts since 1709 Windows build, no need to have exception
     // handling only unwind info for compatibility.
     if (unhandled_exception_callback_g) {
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-base.cc b/src/snapshot/embedded/platform-embedded-file-writer-base.cc
index 1cd402d8ba..c3c9df8fa1 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-base.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-base.cc
@@ -138,7 +138,7 @@ EmbeddedTargetOs ToEmbeddedTargetOs(const char* s) {
     return EmbeddedTargetOs::kFuchsia;
   } else if (string == "ios" || string == "mac") {
     return EmbeddedTargetOs::kMac;
-  } else if (string == "win") {
+  } else if (string == "win" || string == "winuwp") {
     return EmbeddedTargetOs::kWin;
   } else {
     return EmbeddedTargetOs::kGeneric;
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-win.cc b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
index 1aed75eccc..3811ced3df 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-win.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
@@ -503,7 +503,7 @@ void PlatformEmbeddedFileWriterWin::SourceInfo(int fileid, const char* filename,
 void PlatformEmbeddedFileWriterWin::DeclareFunctionBegin(const char* name,
                                                          uint32_t size) {
   if (target_arch_ == EmbeddedTargetArch::kArm64) {
-    fprintf(fp_, "%s%s FUNCTION\n", SYMBOL_PREFIX, name);
+    fprintf(fp_, "\n%s%s FUNCTION\n", SYMBOL_PREFIX, name);
 
   } else {
     fprintf(fp_, "%s%s PROC\n", SYMBOL_PREFIX, name);
diff --git a/src/utils/allocation.cc b/src/utils/allocation.cc
index 6169acbfd6..3f390778e7 100644
--- a/src/utils/allocation.cc
+++ b/src/utils/allocation.cc
@@ -74,8 +74,10 @@ const int kAllocationTries = 2;
 }  // namespace
 
 v8::PageAllocator* GetPlatformPageAllocator() {
-  DCHECK_NOT_NULL(GetPageTableInitializer()->page_allocator());
-  return GetPageTableInitializer()->page_allocator();
+  //DCHECK_NOT_NULL(GetPageTableInitializer()->page_allocator());
+  //return GetPageTableInitializer()->page_allocator();
+
+  return V8::GetCurrentPlatform()->GetPageAllocator();
 }
 
 v8::PageAllocator* SetPlatformPageAllocatorForTesting(
diff --git a/tools/debug_helper/get-object-properties.cc b/tools/debug_helper/get-object-properties.cc
index 0e8fbf02a6..9eaf2ab7d3 100644
--- a/tools/debug_helper/get-object-properties.cc
+++ b/tools/debug_helper/get-object-properties.cc
@@ -331,7 +331,7 @@ class ReadStringVisitor : public TqObjectVisitor {
           Isolate::FromRoot(GetIsolateRoot(heap_addresses_.any_heap_pointer)),
           resource_data));
 #else
-      uintptr_t data_address = reinterpret_cast<uintptr_t>(resource_data);
+      uintptr_t data_address = static_cast<uintptr_t>(resource_data);
 #endif  // V8_COMPRESS_POINTERS
       if (done_) return;
       ReadStringCharacters<TChar>(object, data_address);
